<!DOCTYPE html>
<html
  dir="ltr"
  lang="en"
  data-theme=""
  class="html"
><head>
  <title>
    Liwei Xu
        |
        依赖倒置、控制反转和依赖注入


      


    

  </title>

  
  <meta charset="utf-8" /><meta name="generator" content="Hugo 0.102.3" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="author" content="Liwei Xu" />
  <meta
    name="description"
    content=""
  />
  
  
    
    
    <link
      rel="stylesheet"
      href="/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css"
      integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o="
      crossorigin="anonymous"
      type="text/css"
    />

  

  
  <link
    rel="stylesheet"
    href="/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css"
    integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU="
    crossorigin="anonymous"
    type="text/css"
  />
  
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/fontawesome.min.7f3c2281c7f965ce3c64888aa452793252a0416909c181097f81d0a0f7d1624e.css"
    integrity="sha256-fzwigcf5Zc48ZIiKpFJ5MlKgQWkJwYEJf4HQoPfRYk4="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/solid.min.35fc032da8ede6681675d20a2f862fb9e1045c1d512d495fcf862c054daffef2.css"
    integrity="sha256-NfwDLajt5mgWddIKL4YvueEEXB1RLUlfz4YsBU2v/vI="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/regular.min.3b92357925ea7284f0c6b0378396f39f470f7842ed9702f337e667c4026bf837.css"
    integrity="sha256-O5I1eSXqcoTwxrA3g5bzn0cPeELtlwLzN&#43;ZnxAJr&#43;Dc="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link
    rel="stylesheet"
    href="/fontawesome/css/brands.min.ebb1096e1976e8cc4e2532cfa050b8f30eb13b8eb06be5cee3e38eb426b838ea.css"
    integrity="sha256-67EJbhl26MxOJTLPoFC48w6xO46wa&#43;XO4&#43;OOtCa4OOo="
    crossorigin="anonymous"
    type="text/css"
  />
  
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />

  <link rel="canonical" href="https://xuliwei.xzy/posts/dip-ioc-di/" />

  
  
  
  
  <script
    type="text/javascript"
    src="/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js"
    integrity="sha256-&#43;RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI="
    crossorigin="anonymous"
  ></script>

  
    
    
    <script
      type="text/javascript"
      src="/js/anatole-theme-switcher.min.738c0e3a493854876aeab9e2316fd43f1936aeeac4cc6b3e60bb26456dba72ad.js"
      integrity="sha256-c4wOOkk4VIdq6rniMW/UPxk2rurEzGs&#43;YLsmRW26cq0="
      crossorigin="anonymous"
    ></script>

  

  


  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="依赖倒置、控制反转和依赖注入"/>
<meta name="twitter:description" content="依赖倒置 依赖倒置原则（Dependency inversion principle，DIP）也可以翻译成依赖反转原则，是一个面向对象的设计原则，旨在解耦模块之间的关系。该原则要求： 高层模块不再依赖于低层模块，它们都依赖于抽象； 抽象不应该依赖于具体细节，细节应该"/>



  
  <meta property="og:title" content="依赖倒置、控制反转和依赖注入" />
<meta property="og:description" content="依赖倒置 依赖倒置原则（Dependency inversion principle，DIP）也可以翻译成依赖反转原则，是一个面向对象的设计原则，旨在解耦模块之间的关系。该原则要求： 高层模块不再依赖于低层模块，它们都依赖于抽象； 抽象不应该依赖于具体细节，细节应该" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xuliwei.xzy/posts/dip-ioc-di/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-08T12:10:21+08:00" />
<meta property="article:modified_time" content="2019-04-08T12:10:21+08:00" /><meta property="og:site_name" content="只言片语" />




  
  
  
  
  <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "articleSection": "posts",
        "name": "依赖倒置、控制反转和依赖注入",
        "headline": "依赖倒置、控制反转和依赖注入",
        "alternativeHeadline": "",
        "description": "
      
        依赖倒置 依赖倒置原则（Dependency inversion principle，DIP）也可以翻译成依赖反转原则，是一个面向对象的设计原则，旨在解耦模块之间的关系。该原则要求： 高层模块不再依赖于低层模块，它们都依赖于抽象； 抽象不应该依赖于具体细节，细节应该


      


    ",
        "inLanguage": "en-us",
        "isFamilyFriendly": "true",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xuliwei.xzy\/posts\/dip-ioc-di\/"
        },
        "author" : {
            "@type": "Person",
            "name": "Liwei Xu"
        },
        "creator" : {
            "@type": "Person",
            "name": "Liwei Xu"
        },
        "accountablePerson" : {
            "@type": "Person",
            "name": "Liwei Xu"
        },
        "copyrightHolder" : {
            "@type": "Person",
            "name": "Liwei Xu"
        },
        "copyrightYear" : "2019",
        "dateCreated": "2019-04-08T12:10:21.00Z",
        "datePublished": "2019-04-08T12:10:21.00Z",
        "dateModified": "2019-04-08T12:10:21.00Z",
        "publisher":{
            "@type":"Organization",
            "name": "Liwei Xu",
            "url": "https://xuliwei.xzy",
            "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/xuliwei.xzyfavicon-32x32.png",
                "width":"32",
                "height":"32"
            }
        },
        "image": 
      [
      ]

    ,
        "url" : "https:\/\/xuliwei.xzy\/posts\/dip-ioc-di\/",
        "wordCount" : "2722",
        "genre" : [ ],
        "keywords" : [ ]
    }
  </script>



</head>
<body
    
      class="body theme--light"

    
  >
    <div class="wrapper">
      <aside
        
          class="wrapper__sidebar"

        
      ><div
  class="sidebar
    animated fadeInDown

  "
>
  <div class="sidebar__content">
    <div class="sidebar__introduction">
      <img
        class="sidebar__introduction-profileimage"
        src="/images/profile.jpg"
        alt="profile picture"
      />
      
        <div class="sidebar__introduction-title">
          <a href="/">只言片语</a>
        </div>

      
      <div class="sidebar__introduction-description">
        <p></p>
      </div>
    </div>
    <ul class="sidebar__list">
      
    </ul>
  </div><footer class="footer footer__sidebar">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        Liwei Xu
        2022


      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js"
    integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ="
    crossorigin="anonymous"
  ></script></div>
</aside>
      <main
        
          class="wrapper__main"

        
      >
        <header class="header"><div
  class="
    animated fadeInDown

  "
>
  <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
    <span aria-hidden="true" class="navbar-burger__line"></span>
  </a>
  <nav class="nav">
    <ul class="nav__list" id="navMenu">
      
      
        
        
          <li class="nav__list-item">
            <a
              
              href="/"
              
              title=""
              >Home</a
            >
          </li>

        


      
    </ul>
    <ul class="nav__list nav__list--end">
      
      
        <li class="nav__list-item">
          <div class="themeswitch">
            <a title="Switch Theme">
              <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
          </div>
        </li>

      
    </ul>
  </nav>
</div>
</header>
  <div
    class="post 
      animated fadeInDown

    "
  >
    
    <div class="post__content">
      <h1>依赖倒置、控制反转和依赖注入</h1>
      <h2 id="依赖倒置">依赖倒置</h2>
<p>依赖倒置原则（Dependency inversion principle，DIP）也可以翻译成依赖反转原则，是一个面向对象的设计原则，旨在解耦模块之间的关系。该原则要求：</p>
<ul>
<li>高层模块不再依赖于低层模块，它们都依赖于抽象；</li>
<li>抽象不应该依赖于具体细节，细节应该依赖于抽象。</li>
</ul>
<p>首先说明什么是依赖，在代码层面上，一般认为当 A 的改变会影响 B 时，那么就称 B 依赖于 A。其次说明什么是抽象，根据维基百科，In computer science, abstraction is a mechanism and practice to reduce and factor out details so that one can focus on a few concepts at a time。这里的抽象未必是接口，C# 中的接口、abstract 类、委托以及 lambda 表达式都是抽象，而像 Python 这样的动态语言对象天生就可以表现为抽象的形式。甚至哪怕是一些具体的类型，只要它是 a mechanism and practice to reduce and factor out details so that one can focus on a few concepts at a time，那么它就是抽象。</p>
<p>DIP 中之所以称为依赖倒置，是因为传统的软件开发方法中，比如结构化分析和设计，总是倾向于创建一些高层模块依赖于低层模块、策略（policy）依赖于细节的软件结构。比方代码中要使用一个类库的方法，那么就会实例化一个该类库的对象，此时类库（即细节）是低层模块，所写的逻辑代码（即策略）是高层模块。这种使用方式下，逻辑代码依赖于这个类库，一旦这个类库变了，那么代码逻辑很有可能也要跟着改变。从面向过程的设计和思考角度来看，这种代码复用是很合理的。</p>
<p>但在别的场景下，这么做就有可能不合适了。比如要实现一个写日志的逻辑，允许用户自定义具体写日志的方式，可以写进数据库，也可以写进文件中。由于现在用户的代码还没有，所以无法直接依赖用户的实现，那么只能通过依赖于抽象来实现。比如说将以下写日志的逻辑代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SomeBizClass</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Log(<span style="color:#66d9ef">string</span> msg)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> logger = <span style="color:#66d9ef">new</span> DBLogger();
</span></span><span style="display:flex;"><span>        logger.Log(msg);
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>修改为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SomeBizClass</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Log(ILogger logger, <span style="color:#66d9ef">string</span> msg)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        logger.Log(msg);
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样一来只要接口不变，无论是添加新的日志方式，还是修改原有的日志实现，这段代码都不需要进行任何改动。因为此时高层代码（写日志逻辑）和低层代码（日志实现）已经解耦了。</p>
<p>在依赖倒置的原则下，每个较高层次都为它所需要的服务声明一个抽象接口。由于低层模块实现了抽象（接口），所以它不再被依赖，而是依赖于这些高层模块中所定义的抽象。高层模块使用的是抽象而不是具体低层模块，因此也依赖于抽象。同时，由于此时细节（即低层模块）的改变不会影响接口，相反改变了接口则需要改变具体的细节实现，因此做到了抽象不依赖于细节，细节依赖于抽象。</p>
<p>R.C.Martin 在关于 DIP 的介绍中提到了一个简单的 heuristic（即虽然不够全面但够用的基于经验的技术）：依赖于抽象。即不应该依赖于具体类，程序中所有的依赖关系都应该终止于抽象类或者接口。根据这个 heuristic：</p>
<ul>
<li>任何变量都不应该持有一个指向具体类的指针或者引用；</li>
<li>任何类都不应该从具体类派生；</li>
<li>任何方法都不应该覆写它的任何基类中的已经实现了的方法。</li>
</ul>
<p>实际上程序中很难完全做到这一点，有时候还是会实例化一些类，依赖于一些具体的对象。如果这些对象是基本不会改变的，那么依赖它们也没什么大碍。另一方面，即使做到了这一点，有时候有些类的接口是必须要变化的，它也会影响到这个类的抽象接口。这样就破坏了接口所维系的隔离性。所以说，这个 heuristic 太过简单，并非所有地方都一定不用具体类而是用接口，而是在客户程序客户程序（高层模块）使用低层模块的地方，通过让客户程序声明接口的方式来实现依赖倒置，这样只有客户程序需要改变时才会对接口进行改变。</p>
<h2 id="控制反转">控制反转</h2>
<p>介绍控制反转前先介绍一个概念，叫<a href="https://en.wikipedia.org/wiki/Control_flow">控制流（control of flow）</a>。计算机科学中的控制流是命令式程序中单个语句、指令或者函数调用的执行或计算时的顺序。控制反转（Inversion of control，IOC）就是一种控制流，在这里不再是开发者所写的应用程序来控制流程并调用框架的方法，而是框架提供控制流，并调用开发者所提供的实现。这里的反转指的就是主控权的反转，应用程序到了框架。</p>
<p>举个例子，早期的软件开发没有框架的概念，所有的控制都是程序编写者来编写。比如 MVC 的架构下，要自己通过控制器从视图上获取输入，调取模型进行处理，然后反馈给视图，这一切都通过手动编码来完成。后来有了框架，软件编写变得简单了。我们只要按照框架的接口绘制好视图，建好模型，编写好控制器处理程序即可，一切的控制都由框架来完成了。这就形成了反转，即控制从编写代码的人手上反转到了框架手里。</p>
<h2 id="依赖注入">依赖注入</h2>
<p>控制反转是一个很通用的概念，所有的框架几乎都是控制反转的体现。而框架在使用控制反转后，有一个很重要的事情就是如何定位插件（即找到开发者按照约定编写的代码）。2004 年 Martin Fowler 在他的<a href="https://www.martinfowler.com/articles/injection.html">一篇文章</a>中给当时流行的 IOC 容器使用的定位方式起名为依赖注入（Dependency Injection，DI）。</p>
<p>依赖注入的基本思想是，只要插件遵循一定的规则，那么一个单独的组装器模块（assembler module）就会将实现注入到程序中。有三种主要的依赖注入方式：</p>
<ul>
<li>构造器注入（Constructor Injection）</li>
<li>设置器注入（Setter Injection）</li>
<li>接口注入（Interface Injection）</li>
</ul>
<p>构造器注入和设置器注入的本质是一样的，都是在类中定义一个接口，在运行时通过函数传参的方式传入具体接口实现对象，区别在于一个是通过构造函数，一个是通过专门的设置函数，下面的例子中列出了这两种方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogManager</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ILog _loger;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Log(<span style="color:#66d9ef">string</span> msg)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _loger.Log(msg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//构造器注入</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> LogManager(ILog loger)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _loger = loger;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//设置器注入</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SetLoger(ILog loger)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _loger = loger;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>以上代码是用来声明插件所在的位置，具体的插件的注入则会在一个专门的类中通过代码配置，或者在一个 XML 文件中配置，这个每个 IOC 容器的代码不一样，就不举例了。</p>
<p>接口注入对应用程序代码的侵入性更大一点，需要声明一个接口，在接口中定义需要注入的信息，并通过该接口完成注入。比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ILogerManager</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> InjectLoger(ILoger loger);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogerManager</span>:ILogerManager
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ILoger _loger;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> InjectLoger(ILoger loger)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _loger = loger;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Log(<span style="color:#66d9ef">string</span> msg)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _loger.Log(msg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同样，需要一些代码或文件配置来注入。</p>
<h2 id="依赖注入和策略模式之间的关系">依赖注入和策略模式之间的关系</h2>
<p>以上的部分其实在中文技术博客中是很常见的，不过我在真实项目中自己重构的时候则遇到这样的疑问，除却IOC容器的使用外，如果自己在编码中注入依赖，和使用策略模式有什么区别。这个疑问中文互联网上鲜有提及，可能是大家都不会被这个困扰。</p>
<p>最终我在 Stack Overflow 上找到了一个不错的解释：依赖注入和策略模式本质上都是通过接口来解耦，二者的主要区别要实现的目的上。如果需要创建一个在运行时固定的对象，策略模式和依赖注入几乎效果是一样的。当对象的依赖关系会在运行时会发生变化时，一般使用策略模式。运行时不会发生变化的情况，比如向框架中注入接口实现，则更多的使用依赖注入。另外，在单元测试中一般用依赖注入的情况更多一点。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency inversion principle - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of control - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency injection - Wikipedia</a></li>
<li><a href="https://martinfowler.com/articles/injection.html">Inversion of Control Containers and the Dependency Injection pattern </a></li>
<li><a href="https://www.cnblogs.com/leoo2sk/archive/2009/06/17/1504693.html">依赖注入那些事儿</a></li>
<li><a href="http://stackoverflow.com/questions/4176520/what-is-the-difference-between-strategy-pattern-and-dependency-injection">依赖注入和策略模式的关系</a></li>
</ul>
</div>
    <div class="post__footer">
      

      
    </div>

    
  </div>


      </main>
    </div><footer class="footer footer__base">
  <ul class="footer__list">
    <li class="footer__item">
      &copy;
      
        Liwei Xu
        2022


      
    </li>
    
  </ul>
</footer>
  
  <script
    type="text/javascript"
    src="/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js"
    integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ="
    crossorigin="anonymous"
  ></script></body>
</html>
